#multi-thread study note

1.AQS(AbstractQueuedSynchronizer)：JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架。
JUC中CountDownLatch，Semaphore，ReentrantLock，FutureTask都是基于它实现的。

AQS的核心思想:
如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效工作线程，并且将共享资源设置为锁定状态；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制在AQS中是使用CLH队列锁来实现的，即将暂时获取不到锁的线程加入到队列中。CLH队列是一个虚拟双向队列，即不存在队列实例，仅存在结点之间的关联关系。AQS将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

AQS实现：
AQS维护一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。
state访问方式有下面三种：
	getState()
	setState()
	compareAndSetState()

AQS定义两种资源共享方式：
	Exclusive，独占：只有一个线程能执行，比如ReentrantLock。
	Share，共享：多个线程可同时执行，比如Semaphore和CountDownLatch。
不同的自定义同步器争用共享资源的方式也不同。自定同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队或唤醒出队等）AQS已经在顶层实现好。

自定义同步器实现时主要实现以下几种方法：
isHeldExclusively()：该线程是否正在独占资源，只有用到Condition才需要实现它。
tryAcquire(int)：独占方式，尝试获取资源，成功返回true；失败返回false。
tryRelease(int)：独占方式，尝试释放资源，成功返回true；失败返回false。
tryAcquireShared(int)：共享方式，尝试获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)：共享方式，尝试释放资源，成功返回true；失败返回false。

2.ReentrantLock
state初始化为0，表示未锁定状态。
A线程lock()时，会调用tryAcquire()独占该锁并将state加1。此后，其他线程再尝试获取tryAcquire()时就会失败，直到A线程unlock()到state为0（即释放锁）为止，然后其他线程才有机会获取该锁。
当然，释放锁之前，A线程自己是可以重复获取此锁的，state会累加，这就是可重入的概念。获取多少次就要释放多少次，这样才能保证state是能回到0状态的。

公平锁和非公平锁
公平锁保证了先在队列中的线程先获得锁
