1.JVM内存模型
a.程序计数器：当前线程所执行的字节码的行号指示器，是线程私有的。
b.Java虚拟机栈：是线程私有的，与线程的生命周期相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
c.本地方法栈：执行本地方法服务的。
d.Java堆：虚拟机管理的内存中最大的一块，是被所有线程共享的，在虚拟机启动的时候创建，用来存放对象实例。所有的对象和数组都要在堆上分配。
e.Java堆可以分为新生代和老年代；新生代可分为Eden空间，From Suvivor空间和To Suvivor空间等。
f.方法区：是各个线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

2.volatile
  保证了不同线程对该变量操作的内存可见性。
  禁止指令重排序。

3.垃圾回收算法
  a.标记-清除
    首先标记出所有需要回收的对象，在标记完成之后要统一回收所有被标记的对象。
    标记和清除的效率都不高，在标记清除之后会产生大量不连续的空间碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，
    无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
  b.复制（新生代中的的Survivor区采用的是这个算法）
    复制算法将内存划分为大小相等的两块，每次只使用其中的一块。
    当一块内存使用完了，就将还存在着的对象复制到另外一块上，然后把已使用的内存空间一次清理掉。
    但是这样就会把内存缩小为原来的一半，代价有点高。
  c.标记-整理（老年代采用）
    标记过程首先标记出需要清理的对象，然后将所有存活的对象都向一端移动，最后直接清理掉端边界以外的内存。
  d.分代收集
    分代收集是将上面的算法组合使用，Java堆一般分为新生代和老年代，新生代使用复制算法，老年代使用标记整理或者标记清理算法。
 
 4.内存分配策略
 a.对象优先分配在新生代的Eden区，当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC。如果还找不到足够空间，就通过担保机制提前分配到老年代中去。
 b.大对象直接进入老年代，虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。
 这样做的目的是避免在Eden区以及两个Survivor区域之间发生大量的内存复制。
 c.动态对象年龄判定，如果Survivor区中相同年龄的对象大小总和大于Survivor空间的一半，则年龄大于或者等于该年龄的对象直接进入老年代。
 d.空间分配担保，每次进行Minor GC时，JVM会计算Survivor区移到老年代的对象的平均大小。
 如果这个值大于老年代的剩余值大小则进行一次Full GC，如果小于就检查HandlePromotionFailure设置，
 如果为true，就进行Minor GC，如果为false就进行Full GC。
 
 5.GC类型
a.Minor GC，发生在新生代的垃圾收集动作，Minor GC发生频繁，回收速度也比较快。
b.Major GC/Full GC，发生在老年代的GC，出现了Major GC一般会伴随至少一次Minor GC。Major GC一般会比Minor GC慢10倍。

6.类的生命周期
a.加载:是将二进制文件加载到jvm方法区的过程
b.链接：
    验证：保证Class文件符合jvm虚拟机的要求。会包括文件格式验证，元数据验证，字节码验证和符号引用的验证。
    准备
    解析
c.初始化
d.使用
e.卸载
